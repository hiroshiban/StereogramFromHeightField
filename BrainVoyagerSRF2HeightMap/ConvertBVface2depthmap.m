function img=ConvertBVface2depthmap(face_srf_file,sampling_method,xcut,framing,step,dist_threshold,display_flg)

% Converts a BrainVoyager head surface (*.srf) file to a depth map.
% function img=ConvertBVface2depthmap(face_srf_file,:sampling_method,:xcut,:framing,:step,:dist_threshold,:display_flg)
% (: is optional)
%
% This function converts a BrainVoyager head surface (*.srf) file
% generated by
% 1. Loading a *.vmr file (without skull stripping) onto BrainVoyager
% 2. Creating a mesh for the VMR file by pressing the upper right-most button (a grid dice icon)
% 3. Morphing the mesh to the head surface by pressing the upper second right button (a man icon)
% 4. Saving them as a *.srf file.
%
% NOTE 1: The input *.vmr should be in the standard BrainVoyager coordinate.
%
% NOTE 2: This function is just for a fun and for using BrainVoyager surfaces
%         as visual stimuli on my research topics, 3D vision, visual perception, etc.
%
% [input]
% face_srf_file : BrainVoyager head surface file (*.srf), specified with
%                 a relative path format, in which the location where this
%                 function is called is an origin of the path.
% sampling_method : (optional) sampling method.
%                 1 = nearest neighbor samplings
%                 2 = linear averaging of depth nodes within a dist_threshold-radius sphere
%                 1 by default.
% xcut          : (optional) cutoff of the image along x-axis (front-back), 130 by default.
% framing       : (optional) framing of the VMR, 256 by default.
%                 Depth sampling is done on a framing/step x framing/step grid.
% step          : (optional) step of nearest neighbor samplings of the depth, 0.5 (mm) by default.
%                 The final output image size is framing/step x framing/step
% dist_threshold: (optional) distance threshold used in depth samplings, 4 (mm) by default.
% display_flg   : (optional) whether displaying the generated depth map, [0|1]. 0 by default.
%
% [output]
% img           : a depth map
% the generated depth map is saved as *.srf.png in the same directory with the face_srf_file.
%
% [dependency]
% BVQX_tools v0.8d
%
%
% Created    : "2017-09-26 12:12:24 ban"
% Last Update: "2021-06-13 22:51:00 ban"

% check the input variable.
if nargin<1 || isempty(face_srf_file), help(mfilename()); return; end
if nargin<2 || isempty(sampling_method), sampling_method=1; end
if nargin<3 || isempty(xcut), xcut=130; end
if nargin<4 || isempty(framing), framing=256; end
if nargin<5 || isempty(step), step=0.5; end
if nargin<6 || isempty(dist_threshold), dist_threshold=4; end
if nargin<7 || isempty(display_flg), display_flg=0; end

if ~exist(fullfile(pwd,face_srf_file),'file')
  error('face_srf_file not found. check the input variable.');
end

% processing
[srfpath,srffname,srfext]=fileparts(face_srf_file);
fprintf('converting head VMR file: %s%s --> %s%s.png...',srffname,srfext,srffname,srfext);

srf=BVQXfile(fullfile(pwd,face_srf_file));

% get the indices of the vertices which are in x_coordinates < xcut
idx=find(srf.VertexCoordinate(:,1)<xcut);
depth=255-srf.VertexCoordinate(idx,1); % x-axis = front-back
x_coords=srf.VertexCoordinate(idx,3);         % y-axis = upper-lower
y_coords=srf.VertexCoordinate(idx,2);         % z-axis = left-right

% sampling the depth along a framing x framing (by step mm) grid
[X,Y]=meshgrid(1:step:framing,1:step:framing);

img=zeros(size(X));
for yy=1:1:size(Y,1)
  for xx=1:1:size(X,2)
    distance=((x_coords-X(yy,xx)).^2+(y_coords-Y(yy,xx)).^2);

    if sampling_method==1 % nearest neighbor sampling
      [min_dist,min_idx]=min(distance(:));
      if min_dist<dist_threshold^2
        if depth(min_idx)-xcut<0
          % do nothing
        elseif img(yy,xx)==0
          img(yy,xx)=depth(min_idx)-xcut;
        elseif img(yy,xx)<depth(min_idx)-xcut
          img(yy,xx)=depth(min_idx)-xcut;
        end
      end
    else % if sampling_method==2 % linear averaging within a dist_threshold-radius sphere
      min_idx=find(distance(:)<dist_threshold^2);
      if ~isempty(min_idx)
        if mean(depth(min_idx))-xcut<0
          % do nothing
        elseif img(yy,xx)==0
          img(yy,xx)=mean(depth(min_idx))-xcut;
        elseif img(yy,xx)<mean(depth(min_idx))-xcut
          img(yy,xx)=mean(depth(min_idx))-xcut;
        end
      end
    end

  end
end

% scaling
img(img<0)=0;
img=10.*img;
img=255.*(img-min(img(:)))./(max(img(:))-min(img(:)));

% adjusting the image matrix
if mod(size(img,1),2)==1, img(end+1,:)=0; end
if mod(size(img,2),2)==1, img(:,end+1)=0; end

% saving
img=uint8(img);
imwrite(img,fullfile(pwd,[srffname,srfext,'.png']),'png');

if display_flg
  figure('Name',sprintf('%s%s',srffname,srfext));
  imshow(img,[0,255]);
  axis off;
  colormap(gray(256));
  h=colorbar();
  h.Label.String='Depth map (cm)';
  title('depth map converted from BrainVoyager head surface.');
end

disp('done.');

return
